f0 <- function() {
	in_env <- new.env(parent = emptyenv());
	in_env$x <- 0;

	f1 <- function(env) {
		y <- env$x;
		y <- y + 1;
		assign("x" , y, envir = env);
	    }

	f1(in_env);
    }

sigmoid <- function(params, g) {
    exp(params[1] - params[2]*g) / (1 + exp(params[1] - (g * params[2])));
    }

sigmoid.up <- function(params, g) {
    exp(params[1] + params[2]*g) / (1 + exp(params[1] + (g * params[2])))
    }

make_polygon <- function(
    x0,
    y0,
    x1,
    x2,
    wid = 1,
    len = 1,
    col = 'gray',
    sig_shape = 4,
    beta_in = 3
    ) {

    vaf <- wid;

	beta <- len / beta_in;
	y1 <- max(y0 + beta, y0 + 1);
	yy <- seq(y0, y1, length.out = 100);

    params.d  <- c(-0.7310133, sig_shape);
	y.ex <- seq(-1, 1.5, length.out = length(yy));
	xu.2 <- sigmoid(params.d, y.ex);

	#scale and shift each sigmoid
	x.rt.d <- (xu.2 - min(xu.2)) / (max(xu.2 - min(xu.2))) * (x0 - x2) + x2;
	x.rt.u <- (-xu.2 - max(-xu.2)) / (max(xu.2 + max(-xu.2))) * (x1 - x0) + x1;

	yy.plot <- c(y0, yy, y0 + len, y0 + len, rev(yy));
	xx <- c(x0, x.rt.u, x1, x2, rev(x.rt.d));

	return(list(
	    x = xx,
	    y = yy.plot,
	    col = col
	    ));  
    }

position_polygons <- function(
    clone_env,
    i,
    wid,
    x,
    y,
    len,
    sig_shape = 4,
    beta_in = 3,
    branching = TRUE,
    fixed_angle = NULL,
    no_ccf = FALSE
    ){

    v <- clone_env$v;
	tree <- clone_env$tree;
	clones <- clone_env$clones;

	# get the row of v that corresponds to the clone
	vi <- v[i,];

	if (!is.na(vi$parent) && vi$parent == -1 && nrow(v[v$parent==-1, ]) == 1) { 
	    # If root the clone extends the full width of the plot
		x0 <- x;
		y0 <- y;
		len0 <- len;
		x1 <- vi$x1;
		x2 <- vi$x2;
	} else { 
	    # Parent not root -- not trunk clone
		if (vi$parent == -1) {
			par <- data.frame(
			    lab = -1,
			    x = 0,
			    y = 0,
			    len = len,
			    x.mid = 0,
			    x1 = min(v$x1),
			    x2 = max(v$x2)
			    );
		} else {
			par <- v[v$id == vi$parent,]; # Parent clone
		    }

	    x_mid <- vi$x.mid;
		x1 <- vi$x1;
		x2 <- vi$x2;

		siblings <- v[which(v$parent == par$id), ];

		if (nrow(siblings) == 1) {
			dist <- par$x.mid-par$x;
			parent_angle <- ifelse(
			    is.null(fixed_angle) & no_ccf == FALSE,
			    yes = atan(dist / par$len),
			    no = 0
			    );
		} else if (nrow(siblings) == 2) {
			sibling_coords <- c(siblings$x1, siblings$x2);
			x1_max <- sibling_coords[which.max(abs(sibling_coords))];
			x2_max <- sibling_coords[which.max(abs(sibling_coords - x1_max))];

			dist <- abs(x1_max - x2_max) / 2;

			if (x_mid > par$x.mid) {
				parent_angle <- ifelse(
				    is.null(fixed_angle),
				    yes = atan(dist / par$len),
				    no = fixed_angle
				    );

				parent_angle <- min(parent_angle, 40 / 180 * pi);
			} else if (x_mid < par$x.mid) {
				parent_angle <- ifelse(
				    is.null(fixed_angle),
				    yes = atan(-(dist / par$len)),
				    no = -(fixed_angle)
				    );

				parent_angle <- max(parent_angle, -40 / 180 * pi)
			} else {
				dist <- par$x.mid - par$x;
				parent_angle <- atan(dist / par$len);
			    }
		} else {
			if(v$id == siblings$id[which.min(siblings$x.mid)]){ #align leftmost child with the left outer clone border
				parent_angle <- ifelse(
				    is.null(fixed_angle),
				    yes = atan(-(abs(par$x1) / par$len)),
				    no = -(fixed_angle)
				    );
			} else if(v$id == siblings$id[which.max(siblings$x.mid)]){ #align rightmost child with the right outer clone border
				parent_angle <- ifelse(
				    is.null(fixed_angle),
				    yes = atan(abs(par$x1)/par$len),
				    no = fixed_angle
				    );     
			} else{
				parent_angle <- if (par$len > 0) {
				    atan((vi$x.mid - par$x.mid) / par$len)
			    } else {
			        0
			        };
			    }
		    }

		r <- tree$length[which(tree$parent == par$id & tree$tip == vi$id)];
		x.shift <- r * sin(parent_angle);
		x0 <- par$x + x.shift;
		y.shift <- r * cos(parent_angle);
		y0 <- par$y + y.shift;
		len0 <- par$len - y.shift;

		if (par$id != -1 & len0 >= 0) {
			#make sure the node isn't outside of the parent clone
			par.coords <- data.frame(
			    x = clones[[as.integer(which(v$id == par$id))]][["x"]],
			    y = clones[[as.integer(which(v$id == par$id))]][["y"]]
			    );

			par$x1 <- clones[[as.integer(which(v$id == par$id))]][["x1"]];
			par$x2 <- clones[[as.integer(which(v$id == par$id))]][["x2"]];
			par.coords.pos <- par.coords[1:match(par$x1,par.coords$x), ];
			par.coords.neg <- par.coords[match(par$x2,par.coords$x):length(par.coords$x), ];

			match.x.pos  <- par.coords.pos$x[which.min(abs(par.coords.pos$y - y0))];
			match.x.neg  <- par.coords.neg$x[which.min(abs(par.coords.neg$y - y0))];

			while ((match.x.pos > x0 & match.x.neg > x0) | (match.x.pos < x0 & match.x.neg < x0)) {
				closer <- ifelse(match.x.pos > x0, min(match.x.pos,match.x.neg), max(match.x.pos,match.x.neg));
				further <- ifelse(match.x.pos > x0, max(match.x.pos,match.x.neg), min(match.x.pos,match.x.neg));
				x0 <- closer + 0.15 * (further - closer);
				x.shift <- x0 - par$x;
				x0 <- par$x + x.shift;
				parent_angle <- asin(x.shift / r);
				angle_x <- par$x + r * sin(parent_angle);
				y.shift <- r * cos(parent_angle);
				y0 <- par$y + y.shift
				match.x.pos  <- par.coords.pos$x[which.min(abs(par.coords.pos$y - y0))];
				match.x.neg  <- par.coords.neg$x[which.min(abs(par.coords.neg$y - y0))];
			    }
		    }
	
		len0 <- par$len - y.shift;
		tree$angle[which(tree$parent == par$id & tree$tip == vi$id)] <- parent_angle;
	    }

	v[i,]$len <- len0;
	v[i,]$y <- y0;
	v[i,]$x <- x0;
	clone_env$v <- v;
	clone_env$tree <- tree;

	clone_points <- make_polygon(
	    x0 = x0,
	    y0 = y0,
	    x1 = x1,
	    x2 = x2,
	    wid = wid * vi$vaf,
	    len = len0,
	    col = vi$color,
	    sig_shape = sig_shape,
	    beta_in = beta_in
	    );

 	return(c(
 	    clone_points,
 	    x0 = x0,
 	    y0 = y0,
 	    len = len0,
 	    x1 = x1,
 	    x2 = x2,
 	    alpha = vi$alpha
 	    ));
    }

get_clones <- function(
    x = 0,
    y = 0,
    wid = 1.2,
    len = len,
    sig_shape = 3,
    beta_in = 3,
    branching = FALSE,
    no_ccf = FALSE,
    fixed_angle = NULL,
    spread = 1,
    clone_env = NULL,
    adjust_beta = FALSE
    ){

    clone_env$clones <- list();
    
	clone_env$coords.df <- data.frame(
	    x0 = numeric(length = nrow(clone_env$v)),
	    y0 = numeric(length = nrow(clone_env$v)),
	    len = numeric(length = nrow(clone_env$v)),
	    x1 = numeric(length=(nrow(clone_env$v))),
	    x2 = numeric(length = nrow(clone_env$v))
	    );	   

	for (j in 1:(nrow(clone_env$v))) {
        clone_env$clones[[j]] <- position_polygons(
            clone_env,
            j,
            wid = wid,
            x = x,
            y = y,
            len = len,
            sig_shape = sig_shape,
            beta_in = beta_in,
            branching = branching,
            no_ccf = no_ccf,
            fixed_angle = fixed_angle
            );

		beta.add <- 0.5;

		if (adjust_beta & !no_ccf) {
			#if the polygon gets cut off before it can occupy the full width adjust the beta value to make it curve more sharply
			while(all(clone_env$clones[[j]]$y[which(abs(clone_env$clones[[j]]$x) == max(abs(clone_env$clones[[j]]$x)))] > (clone_env$coords.df$len[1]+y))) {
	            clone_env$clones[[j]] <- position_polygons(
	                clone_env,
	                j,
	                wid = wid,
	                x = x,
	                y = y,
	                len = len,
	                sig_shape = sig_shape,
	                beta_in = beta_in + beta.add,
	                branching = branching,
	                no_ccf = no_ccf,
	                fixed_angle = fixed_angle
	                );

	            for (var in colnames(clone_env$coords.df)) {
		  		    clone_env$coords.df[j,var] <- clone_env$clones[[j]][var];
			        }		

	            beta.add <- beta.add + 0.5;
			    }
		    }

		for (var in colnames(clone_env$coords.df)) {
	   		clone_env$coords.df[j, var] <- clone_env$clones[[j]][var];
    	    }		
    	}
    }

compute_clones <- function(
    v,
    x = 1,
    y = 0,
    wid = 1.2,
    extra.len = 1,
    tree = NULL,
    fixed_angle = NULL,
    sig_shape = 3,
    beta_in = 3,
    branching = TRUE,
    no_ccf = FALSE,
    spread = 1
    ){  

	#make sure the root is properly defined 
	root = v[!is.na(v$parent) & v$parent == -1, ];
	v <- v[is.na(v$parent) | v$parent != -1, ];
	v <- rbind(root, v);

	if (no_ccf && (is.null(fixed_angle) && nrow(v) > 6) || any(table(v$parent) > 2)) {
		v <- count_leaves_per_node(v);
		tmp <-  position_nodes_radial(v, tree, extra.len, spread);
		clone_env <-  new.env(parent = emptyenv());
		clone_env$v <- tmp$v;
		clone_env$tree <- tmp$tree;
		return(clone_env);
	} else if (no_ccf && !is.null(fixed_angle)) {
		#position nodes fixed angle
		clone_env <- position_nodes_fixed(
		    v,
		    tree,
		    fixed_angle = fixed_angle,
		    len = extra.len
		    );

		return(clone_env)
	} else{
		v <- position_clones(v, tree, wid);
    	}

	v$x <- v$y <- v$len <- 0;
	len <- extra.len;

	clone_env <- new.env(parent = emptyenv());
	clone_env$v <- v;
	clone_env$tree <- tree;

	get_clones(
	    x = x,
	    y = y,
	    len = len,
	    sig_shape = sig_shape,
	    beta_in = beta_in,
	    branching = branching,
	    no_ccf = no_ccf,
	    fixed_angle = fixed_angle,
	    spread = spread,
	    clone_env = clone_env
	    );

	#if the end of the polygon is shorter than the last clone polygon or the desired length make the polygon longer and recompute
	while (max(clone_env$coords.df$y0) > (clone_env$coords.df$len[1] + y) | (min(clone_env$coords.df$len) < extra.len )) {
        len <- len + (extra.len-min(clone_env$coords.df$len)) + 0.0001;
    
        get_clones(
             x = x,
             y = y,
             wid = wid,
             len = len,
             sig_shape = sig_shape,
             beta_in = beta_in,
             branching = branching,
             no_ccf = no_ccf,
             fixed_angle = fixed_angle,
             spread = spread,
             clone_env = clone_env
             );
        }

	#if the polygon gets cut off before it can occupy the full width adjust the beta value to make it curve more sharply
	get_clones(
	    x = x,
	    y = y,
	    len = len,
	    sig_shape = sig_shape,
	    beta_in = beta_in,
	    branching = branching,
	    no_ccf = no_ccf,
	    fixed_angle = fixed_angle,
	    spread=spread,
	    clone_env = clone_env,
	    adjust_beta = TRUE
	    );

	return(clone_env);
    }
